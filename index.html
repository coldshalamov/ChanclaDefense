<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chancla Bomb: Isa vs. Su Gringo Para Siempre</title>
    <!-- Force high-quality emoji font for consistent looks across PC and iPhone -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Color+Emoji&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-top: #0d1b2a;
            --bg-bottom: #192f43;
            --accent: #ff79c6;
            --super: #ffb347;
            --text: #f8f8f2;
            --dialog: #1f4068;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at 20% 20%, #1c2f4a 0%, #0b1726 50%, #050910 100%);
            color: var(--text);
            font-family: 'Trebuchet MS', 'Segoe UI', sans-serif;
        }

        .wrapper {
            text-align: center;
        }

        canvas {
            background: linear-gradient(180deg, var(--bg-top) 0%, var(--bg-bottom) 100%);
            border-radius: 16px;
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.35);
            width: min(95vw, 420px);
            aspect-ratio: 4 / 7;
            height: auto;
            touch-action: none;
            display: block;
            margin: 0 auto;
        }

        .mobile-hint {
            color: #d7e8ff;
            font-size: 14px;
            margin-top: 6px;
            letter-spacing: 0.3px;
        }

        #mobile-controls {
            position: relative;
            width: min(95vw, 420px);
            aspect-ratio: 4 / 7;
            margin: 0 auto;
            transform: translateY(-100%);
            pointer-events: none;
        }

        .touch-zone {
            position: absolute;
            bottom: 0;
            width: 50%;
            height: 40%;
            pointer-events: auto;
        }

        .touch-left {
            left: 0;
        }

        .touch-right {
            right: 0;
        }

        .touch-overlay {
            position: absolute;
            inset: 0;
            border-radius: 16px;
            pointer-events: none;
        }

        .touch-visual {
            position: absolute;
            bottom: 16px;
            width: 42%;
            height: 70px;
            border-radius: 18px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0.05));
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fdf5ff;
            font-weight: 700;
            letter-spacing: 0.5px;
            pointer-events: none;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .touch-visual span {
            font-size: 18px;
            display: block;
        }

        .touch-visual-left {
            left: 10px;
        }

        .touch-visual-right {
            right: 10px;
        }

        .touch-visual,
        .mobile-hint {
            transition: transform 0.35s ease, opacity 0.35s ease;
        }

        .hide-directions .touch-visual {
            transform: translateY(140%);
            opacity: 0;
        }

        .hide-directions .mobile-hint {
            transform: translateY(12px);
            opacity: 0;
        }
    </style>
</head>

<body>
    <div class="wrapper">
        <canvas id="game" width="400" height="700"></canvas>
        <div id="mobile-controls">
            <div class="touch-zone touch-left"></div>
            <div class="touch-zone touch-right"></div>
            <div class="touch-overlay" id="overlay-left"></div>
            <div class="touch-overlay" id="overlay-right"></div>
            <div class="touch-visual touch-visual-left"><span>‚¨ÖÔ∏è Drag aqu√≠</span></div>
            <div class="touch-visual touch-visual-right"><span>‚û°Ô∏è Drag aqu√≠</span></div>
        </div>
        <div class="mobile-hint">Mover: ‚Üê/‚Üí | Manotazo: Espacio o Tap Arriba üëã</div>
    </div>
    <script>
        (() => {
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');
            const overlayLeft = document.getElementById('overlay-left');
            const overlayRight = document.getElementById('overlay-right');
            const touchLeft = document.querySelector('.touch-left');
            const touchRight = document.querySelector('.touch-right');
            const body = document.body;
            const wrapper = document.querySelector('.wrapper');

            const STATE = { TITLE: 'title', PLAYING: 'playing', GAMEOVER: 'gameover', WIN: 'win' };
            let state = STATE.TITLE;

            const player = { x: canvas.width / 2, y: canvas.height - 70, w: 55, h: 45, speed: 230, lives: 3, maxLives: 5, shield: false, hitTimer: 0 };
            const isa = { x: canvas.width / 2, y: 70, anger: 100, maxAnger: 100, hitTimer: 0, chismeTimer: 0 };

            let chanclas = [];
            let pets = [];
            let powerups = [];
            let floatTexts = [];
            let rosePetals = [];
            let specialProjectiles = [];
            let score = 0;
            let bestScore = 0;
            let spawnInterval = 1.2;
            let minSpawnInterval = 0.45;
            let spawnTimer = 0;
            let baseSpeed = 140;
            const slowEffect = { timer: 0, factor: 0.62 };
            let timeElapsed = 0;
            let superEnabled = false;
            let specialAttackBar = 0;
            const maxSpecialAttack = 100;
            let slapCooldown = 0;
            const slapEffect = { timer: 0, duration: 0.15 };
            let winAnimationStart = 0;
            let shakeTimer = 0;
            let shakeIntensity = 0;
            let hitStop = 0;
            let impacts = [];
            let chainEffects = [];
            let comboCount = 0;
            const flash = { timer: 0, maxTime: 0, color: '#fff' };
            let specialReadyTriggered = false;

            let dialogueTimer = 0;
            let playerDialogueTimer = 0;
            let dialogueText = '';
            let playerDialogueText = '';
            const dialogueDuration = 3.3;

            const keys = { left: false, right: false };
            const touch = { left: false, right: false };

            // Audio context for sound effects (reuse to avoid browser limits)
            let audioContext = null;
            function getAudioContext() {
                if (!audioContext) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    } catch (e) {
                        // Audio not supported
                    }
                }
                return audioContext;
            }

            const dialogue = {
                start: [
                    "Ya no me amas, verdad?!",
                    "¬°Ya s√© que lo hiciste en la ducha sin grabarlo para m√≠!",
                    "¬°Le voy a dar tu cuerpo a mis gatos, gringo!"
                ],
                hitBySpecial: [
                    "Oh!",
                    "Papi!",
                    "OoOoOoH!"
                ],
                hitNormal: [
                    "¬°Eso te pasa por andar dando like a otras, eh! üòà",
                    "Te dije, mi vida, la chancla siempre encuentra tu cara.",
                    "Ay, gringo, ni esquivar sabes‚Ä¶ ven pa‚Äô ac√°.",
                    "Mira nom√°s, directo en tu carita bonita, jajaja.",
                    "¬°Eso te pasa por andar dando like a otras, eh! üòà",
                    "Te dije, mi vida, la chancla siempre encuentra tu cara.",
                    "Ay, gringo, ni esquivar sabes‚Ä¶ ven pa‚Äô ac√°.",
                    "Mira nom√°s, directo en tu carita bonita, jajaja.",
                    "Solo lo hago porque te amo gringo, ¬°me haces enojar TANTO!"
                ],
                hitSuper: [
                    "Esta es la de 15 cent√≠metros, para que respetes a tu reina. üí•",
                    "Chancla XL activada‚Ä¶ F por tu carita, mi vida.",
                    "Te advert√≠ de la chancla deluxe, ¬øno?"
                ],
                nearMiss: [
                    "Te salvaste por las pesta√±as, ¬øeh?",
                    "Uy, casi te acomodo la nariz, gringuito.",
                    "Te salvaste por las pesta√±as, ¬øeh?",
                    "Uy, casi te acomodo la nariz, gringuito.",
                    "¬°YO NO ESTOY LOCA!"
                ],
                lowHealth: [
                    "¬°NUNCA VES MIS REELS!",
                    "√öltima vida, mi amor‚Ä¶ igual que mi paciencia cuando me dejas en visto.",
                    "Ya casi te mando directo a ‚ÄòGame Over, mi vida‚Äô."
                ],
                gameOver: [
                    "Isa gan√≥, como siempre. üòè",
                    "Game over, mi gringo. ¬øOtra vez o ya te rindes?",
                    "Te lo dije: con chancla no se juega.",
                    "Perdiste, pero igual te amo poquito‚Ä¶ muy poquito."
                ],
                highScore: [
                    "Ok, estoy impresionada‚Ä¶ s√≠ sabes esquivar, ¬øeh?",
                    "Mi gringo pro player, qu√© miedo y qu√© ganas.",
                    "Est√° bien‚Ä¶ hoy guardo la chancla. Pero solo hoy."
                ],
                petOwen: [
                    "Ay, Alecito te protege solo por hojuelas de salm√≥n, qu√© suerte tienes.",
                    "Mira, hasta Owen te defiende de mis chanclas.",
                    "Si sobrevives es por Owen, no por tus reflejos, ¬øeh?"
                ],
                petRita: [
                    "Rita Cat-Alina dice miau y te regala una vida. üê±",
                    "La reina Rita cancel√≥ una chancla por ti, da las gracias.",
                    "Hasta la gata te cuida‚Ä¶ yo solo te aviento chancla."
                ],
                win: [
                    "Te amo, Papi. I only hit you because I love you."
                ],
                slapSuccess: [
                    "¬øC√≥mo te atreves a manotear mis chanclas?!",
                    "Eso no es justo, gringo!",
                    "¬°Ay! Esa es mi chancla favorita!"
                ],
                comboBreaker: [
                    "¬°Te sent√≠as muy salsa, eh?",
                    "Iba bien... hasta que llegu√© yo. üòè",
                    "¬øTe pusiste nervioso, papi?",
                    "Rompiendo tu combo y tu coraz√≥n. üíî"
                ],
                chisme: [
                    "Wait! Maria just posted!",
                    "Omg, hold on, I need to reply to this.",
                    "Pause! Chisme alert!",
                    "¬øQu√© hizo la Karen ahora?",
                    "¬°No me digas! ¬øEn serio?"
                ]
            };

            const gringoLines = {
                fireSpecial: [
                    "I got something that will calm you down!",
                    "Hora del jam√≥n, cari√±o!",
            "Baby, I'm sorry!"
                ],
                idle: [
                    "Woah, woah chill, alright? Chill!",
                    "Ok, I promise I won't say it again just calm down!",
                    "I don't even know her, I was just ordering a coffee!",
                    "Please just relax, I'm sorry!",
                    "Baby, I love you!",
                    "No mas chanclas, mi cielo!"
                ],
                hit: [
                    "SHIT!",
                    "FUCK that hurt!"
                ],
                super: [
                    "Oh my god, what the fuck is that?!",
                    "Not the big shoe! FUCK"
                ],
                nearMiss: [
                    "Ay Dios Mio!",
                    "HOLY SHIT!",
                    "YOU'RE CRAZY!"
                ]
            };

            function sayPlayer(category) {
                const lines = gringoLines[category];
                if (!lines || !lines.length) return;
                playerDialogueText = lines[Math.floor(Math.random() * lines.length)];
                playerDialogueTimer = 2.5;

                if (playerDialogueText === "YOU'RE CRAZY!") {
                    setTimeout(() => {
                        dialogueText = "I'll SHOW YOU CRAZY!";
                        dialogueTimer = 3.0;
                    }, 600);
                }
            }

            function sayRandom(category) {
                const lines = dialogue[category];
                if (!lines || !lines.length) return;
                dialogueText = lines[Math.floor(Math.random() * lines.length)];
                dialogueTimer = dialogueDuration;
            }

            function triggerShake(intensity, duration) {
                shakeIntensity = intensity;
                shakeTimer = duration;
            }

            function triggerFlash(duration, color = '#fff') {
                flash.timer = duration;
                flash.maxTime = duration;
                flash.color = color;
            }

            function resetGame() {
                player.x = canvas.width / 2;
                player.y = canvas.height - 70;
                player.lives = 3;
                player.shield = false;
                player.hitTimer = 0;
                isa.anger = isa.maxAnger;
                isa.x = canvas.width / 2;
                isa.y = 70;
                isa.chismeTimer = 0;
                chanclas = [];
                pets = [];
                powerups = [];
                floatTexts = [];
                rosePetals = [];
                specialProjectiles = [];
                impacts = [];
                score = 0;
                comboCount = 0;
                spawnInterval = 1.2;
                baseSpeed = 140;
                timeElapsed = 0;
                superEnabled = false;
                specialAttackBar = 0;
                slapCooldown = 0;
                winAnimationStart = 0;
                slowEffect.timer = 0;
                shakeTimer = 0;
                hitStop = 0;
                flash.timer = 0;
                specialReadyTriggered = false;
                chainEffects = [];
                wrapper.style.transform = 'none';
                sayRandom('start');
                playerDialogueTimer = 0;
                state = STATE.PLAYING;
                setDirectionsVisible(false);
            }

            function getComboPhrase(c) {
                if (c >= 25) return "LEGEND! üëë";
                if (c >= 15) return "IMPOSSIBLE! ü§Ø";
                if (c >= 10) return "DIOS MIO! üò±";
                if (c >= 6) return "FUEGO! üî•";
                if (c >= 3) return "SPICY! üå∂Ô∏è";
                return "";
            }

            const cityShapes = [];
            const cactusShapes = [];
            const starDots = [];

            function buildBackgroundElements() {
                cityShapes.length = 0;
                cactusShapes.length = 0;
                starDots.length = 0;
                for (let i = 0; i < 6; i++) {
                    const w = 40 + Math.random() * 30;
                    const h = 60 + Math.random() * 80;
                    const x = (canvas.width / 6) * i + Math.random() * 20;
                    const y = canvas.height - h - 20;
                    cityShapes.push({ x, y, w, h });
                }
                for (let i = 0; i < 3; i++) {
                    const baseX = 60 + i * 120 + Math.random() * 40;
                    const baseY = canvas.height - 30;
                    cactusShapes.push({ baseX, baseY });
                }
                for (let i = 0; i < 30; i++) {
                    starDots.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height * 0.6 });
                }
            }

            function drawBackground() {
                const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                grad.addColorStop(0, '#0b1930');
                grad.addColorStop(1, '#0f243a');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#0a1527';
                cityShapes.forEach(b => ctx.fillRect(b.x, b.y, b.w, b.h));

                ctx.fillStyle = '#1b8c6e';
                cactusShapes.forEach(c => {
                    ctx.beginPath();
                    ctx.moveTo(c.baseX, c.baseY);
                    ctx.lineTo(c.baseX + 20, c.baseY - 70);
                    ctx.lineTo(c.baseX + 40, c.baseY);
                    ctx.fill();
                });

                ctx.fillStyle = '#ffe066';
                starDots.forEach(s => ctx.fillRect(s.x, s.y, 2, 2));
            }

            function drawFlash() {
                if (flash.timer <= 0) return;
                const alpha = (flash.timer / flash.maxTime) * 0.45;
                ctx.save();
                ctx.fillStyle = flash.color;
                ctx.globalAlpha = alpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

            function drawRosePetals() {
                rosePetals.forEach(p => {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    if (p.emoji) {
                        ctx.font = (p.size || 20) + 'px "Noto Color Emoji", "Apple Color Emoji", "Segoe UI Emoji", sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(p.emoji, 0, 0);
                    } else {
                        ctx.fillStyle = '#ff4d6d'; // Rose petal pink/red
                        ctx.beginPath();
                        // Simple petal shape
                        ctx.moveTo(0, 0);
                        ctx.bezierCurveTo(5, -5, 10, 0, 10, 5);
                        ctx.bezierCurveTo(10, 10, 0, 15, 0, 10);
                        ctx.bezierCurveTo(-5, 15, -10, 10, -10, 5);
                        ctx.bezierCurveTo(-10, 0, -5, -5, 0, 0);
                        ctx.fill();
                    }
                    ctx.restore();
                });
            }

            function spawnRoseExplosion(x, y) {
                for (let i = 0; i < 12; i++) {
                    const angle = (Math.PI * 2 * i) / 12;
                    const speed = 150 + Math.random() * 100;
                    rosePetals.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        rotation: Math.random() * Math.PI * 2,
                        rotSpeed: (Math.random() - 0.5) * 10,
                        offset: Math.random() * 10
                    });
                }
            }

            function spawnImpact(x, y, isBig = false) {
                impacts.push({ x, y, timer: 0.25, maxTime: 0.25, rotation: Math.random() * Math.PI, isBig });
            }

            function updateImpacts(dt) {
                for (let i = impacts.length - 1; i >= 0; i--) {
                    const imp = impacts[i];
                    imp.timer -= dt;
                    if (imp.timer <= 0) impacts.splice(i, 1);
                }
            }

            function drawImpacts() {
                impacts.forEach(imp => {
                    ctx.save();
                    ctx.translate(imp.x, imp.y);
                    ctx.rotate(imp.rotation);
                    const p = imp.timer / imp.maxTime;
                    const scale = (0.5 + (1 - p) * 1.5) * (imp.isBig ? 1.4 : 1); // Expand quickly
                    ctx.scale(scale, scale);
                    ctx.globalAlpha = p;

                    // Draw a jagged hit shape (starburst)
                    ctx.fillStyle = imp.isBig ? '#fffce0' : '#fff';
                    ctx.beginPath();
                    const spikes = 8;
                    const outerRadius = 30;
                    const innerRadius = 12;
                    for (let i = 0; i < spikes * 2; i++) {
                        const r = (i % 2 === 0) ? outerRadius : innerRadius;
                        const a = (Math.PI * i) / spikes;
                        ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                    }
                    ctx.closePath();
                    ctx.fill();

                    ctx.strokeStyle = imp.isBig ? '#00e5ff' : '#ffb347'; // Cyan for perfect, Orange normal
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    ctx.restore();
                });
            }

            function spawnChainEffect(x1, y1, x2, y2) {
                chainEffects.push({ x1, y1, x2, y2, timer: 0.2, maxTime: 0.2 });
            }

            function updateChainEffects(dt) {
                for (let i = chainEffects.length - 1; i >= 0; i--) {
                    chainEffects[i].timer -= dt;
                    if (chainEffects[i].timer <= 0) chainEffects.splice(i, 1);
                }
            }

            function drawChainEffects() {
                chainEffects.forEach(eff => {
                    ctx.save();
                    const p = eff.timer / eff.maxTime;
                    ctx.globalAlpha = p;
                    // Cyan electricity glow
                    ctx.shadowColor = '#00e5ff';
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = '#00e5ff';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    const segments = 6;
                    ctx.beginPath();
                    ctx.moveTo(eff.x1, eff.y1);

                    const dx = (eff.x2 - eff.x1) / segments;
                    const dy = (eff.y2 - eff.y1) / segments;

                    // Vector for jitter direction (perpendicular)
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const nx = -dy / (len || 1);
                    const ny = dx / (len || 1);

                    for (let i = 1; i < segments; i++) {
                        // More jitter in the middle, less at ends
                        const midFactor = 1 - Math.abs(i - segments / 2) / (segments / 2);
                        const jitter = (Math.random() - 0.5) * 40 * midFactor;
                        const tx = eff.x1 + dx * i + nx * jitter;
                        const ty = eff.y1 + dy * i + ny * jitter;
                        ctx.lineTo(tx, ty);
                    }
                    ctx.lineTo(eff.x2, eff.y2);
                    ctx.stroke();

                    // White hot core
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.shadowBlur = 0;
                    ctx.stroke();

                    ctx.restore();
                });
            }

            function drawSlapEffect() {
                if (slapEffect.timer <= 0) return;

                ctx.save();
                ctx.translate(player.x, player.y - 15);

                const p = 1 - (slapEffect.timer / slapEffect.duration);
                const dir = slapEffect.swipeDir || 1;
                let color = '255, 255, 255';
                let width = 4;
                const alpha = Math.max(0, 1.0 - Math.pow(p, 3));

                if (slapEffect.type === 'hit') {
                    color = '255, 179, 71'; // #ffb347 orange
                    width = 6;
                } else if (slapEffect.type === 'perfect') {
                    color = '0, 229, 255'; // #00e5ff cyan
                    width = 8;
                    ctx.shadowColor = '#00e5ff';
                    ctx.shadowBlur = 10;
                }

                ctx.strokeStyle = 'rgba(' + color + ', ' + alpha + ')';
                ctx.lineWidth = width;
                ctx.lineCap = 'round';

                const baseAngle = 1.5 * Math.PI;
                const sweep = 0.7 * Math.PI;
                const centerAngle = baseAngle + (p - 0.5) * sweep * dir;
                const arcWidth = 0.25 * Math.PI;

                ctx.beginPath();
                ctx.arc(0, 0, 75, centerAngle - arcWidth / 2, centerAngle + arcWidth / 2);
                ctx.stroke();

                // Draw Hand
                const handAngle = dir === 1 ? centerAngle + arcWidth / 2 : centerAngle - arcWidth / 2;
                const handX = Math.cos(handAngle) * 75;
                const handY = Math.sin(handAngle) * 75;

                ctx.translate(handX, handY);
                ctx.rotate(handAngle + Math.PI / 2);
                ctx.font = '30px "Noto Color Emoji", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fillText('‚úã', 0, 0);

                ctx.restore();
            }

            function drawPlayer() {
                const { x, y, w, h } = player;
                ctx.save();
                ctx.fillStyle = '#fff';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('GRINGO', x, y - h / 2 - 10);

                // Determine expression
                let expression = 'normal';
                if (player.hitTimer > 0) expression = 'hit';
                else if (slapEffect.timer > 0) expression = 'slap';
                else if (slowEffect.timer > 0) expression = 'chill';
                else if (comboCount >= 5) expression = 'cocky';

                drawPlayerAvatar(ctx, x, y, Math.min(w, h), specialAttackBar >= maxSpecialAttack, expression);
                if (player.shield) {
                    ctx.strokeStyle = '#9bfffa';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y, w * 0.65, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
            }

            function drawIsa() {
                ctx.save();
                let drawX = isa.x;
                let drawY = isa.y;
                if (isa.hitTimer > 0) {
                    drawX += (Math.random() - 0.5) * 12;
                    drawY += (Math.random() - 0.5) * 12;
                }
                drawIsaAvatar(ctx, drawX, drawY, 78, isa.hitTimer > 0);

                if (isa.chismeTimer > 0) {
                    // Draw phone near Isa
                    ctx.font = '30px sans-serif';
                    ctx.fillText('üì±', drawX + 30, drawY + 20);
                }
                ctx.restore();
            }

            function roundRect(ctx, x, y, w, h, r) {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r);
                ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath();
            }

            function drawIsaAvatar(ctx, x, y, size, isHit) {
                ctx.save();
                ctx.translate(x, y);
                const faceW = size * 0.72;
                const faceH = size * 0.82;
                const hairColor = '#3a2522';
                const skin = '#e7b28f';

                // Flowing hair and bun
                ctx.fillStyle = hairColor;
                ctx.beginPath();
                ctx.moveTo(-faceW / 2 - 14, -faceH / 2 + 16);
                ctx.quadraticCurveTo(-faceW / 2 - 24, -faceH / 2, -faceW / 2 - 6, -faceH / 2 - 12);
                ctx.quadraticCurveTo(-2, -faceH / 2 - 22, faceW / 2 + 10, -faceH / 2 - 6);
                ctx.quadraticCurveTo(faceW / 2 + 20, -faceH / 2 + 12, faceW / 2 + 6, -faceH / 2 + 22);
                ctx.lineTo(faceW / 2 + 10, faceH / 2 - 10);
                ctx.quadraticCurveTo(0, faceH / 2 + 26, -faceW / 2 - 10, faceH / 3);
                ctx.closePath();
                ctx.fill();

                // Bun
                ctx.fillStyle = '#2c1a18';
                ctx.beginPath();
                ctx.ellipse(0, -faceH / 2 - 12, faceW * 0.32, faceH * 0.16, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = skin;
                ctx.beginPath();
                ctx.moveTo(-faceW / 2, -faceH / 2 + 6);
                ctx.quadraticCurveTo(-faceW * 0.55, -faceH * 0.05, -faceW * 0.28, faceH * 0.3);
                ctx.quadraticCurveTo(0, faceH * 0.52, faceW * 0.28, faceH * 0.3);
                ctx.quadraticCurveTo(faceW * 0.55, -faceH * 0.05, faceW / 2, -faceH / 2 + 6);
                ctx.closePath();
                ctx.fill();

                // Cheeks
                ctx.fillStyle = 'rgba(255,126,171,0.55)';
                ctx.beginPath();
                ctx.ellipse(-faceW * 0.22, faceH * 0.1, faceW * 0.12, faceH * 0.08, 0, 0, Math.PI * 2);
                ctx.ellipse(faceW * 0.22, faceH * 0.1, faceW * 0.12, faceH * 0.08, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                if (isHit) {
                    // X Eyes
                    ctx.strokeStyle = '#1d1411';
                    ctx.lineWidth = 3;
                    const drawXEye = (centerX, centerY) => {
                        const r = faceW * 0.09;
                        ctx.beginPath();
                        ctx.moveTo(centerX - r, centerY - r);
                        ctx.lineTo(centerX + r, centerY + r);
                        ctx.moveTo(centerX + r, centerY - r);
                        ctx.lineTo(centerX - r, centerY + r);
                        ctx.stroke();
                    };
                    drawXEye(-faceW * 0.2, -faceH * 0.05);
                    drawXEye(faceW * 0.2, -faceH * 0.05);
                } else {
                    // Normal eyes with lashes
                    ctx.fillStyle = '#1d1411';
                    ctx.beginPath();
                    ctx.arc(-faceW * 0.2, -faceH * 0.05, faceW * 0.08, 0, Math.PI * 2);
                    ctx.arc(faceW * 0.2, -faceH * 0.05, faceW * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#1d1411';
                    ctx.lineWidth = 2.2;
                    const lash = (sx, dir) => {
                        ctx.beginPath();
                        ctx.moveTo(sx, -faceH * 0.15);
                        ctx.quadraticCurveTo(sx + dir * 6, -faceH * 0.18, sx + dir * 12, -faceH * 0.16);
                        ctx.stroke();
                    };
                    lash(-faceW * 0.2, -1);
                    lash(faceW * 0.2, 1);

                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(-faceW * 0.2 + 2, -faceH * 0.07, faceW * 0.03, 0, Math.PI * 2);
                    ctx.arc(faceW * 0.2 + 2, -faceH * 0.07, faceW * 0.03, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Mouth
                if (isHit) {
                    // O mouth
                    ctx.strokeStyle = '#d93c7a';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.ellipse(0, faceH * 0.2, faceW * 0.1, faceH * 0.12, 0, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    // Smile and lips
                    ctx.strokeStyle = '#d93c7a';
                    ctx.lineWidth = 2.4;
                    ctx.beginPath();
                    ctx.arc(0, faceH * 0.15, faceW * 0.2, Math.PI * 0.2, Math.PI * 0.8, false);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-faceW * 0.12, faceH * 0.17);
                    ctx.quadraticCurveTo(0, faceH * 0.22, faceW * 0.12, faceH * 0.17);
                    ctx.stroke();
                }

                // Earrings
                ctx.fillStyle = '#ffef9f';
                ctx.beginPath();
                ctx.arc(-faceW / 2 + 6, faceH * 0.15, faceW * 0.04, 0, Math.PI * 2);
                ctx.arc(faceW / 2 - 6, faceH * 0.15, faceW * 0.04, 0, Math.PI * 2);
                ctx.fill();

                // Headband label
                const labelW = faceW * 0.76;
                const labelH = 20;
                ctx.fillStyle = '#ff7fb6';
                roundRect(ctx, -labelW / 2, -faceH / 2 - labelH - 2, labelW, labelH, 10);
                ctx.fill();
                ctx.strokeStyle = '#c7437e';
                ctx.lineWidth = 1.4;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('ISA', 0, -faceH / 2 - 6);
                ctx.restore();
            }

            function drawPlayerAvatar(ctx, x, y, size, hasRose, expression = 'normal') {
                ctx.save();
                ctx.translate(x, y);

                // Add shake/rotate for hit
                if (expression === 'hit') {
                    ctx.rotate((Math.random() - 0.5) * 0.25);
                } else if (expression === 'chill') {
                    ctx.rotate(Math.sin(timeElapsed * 3) * 0.08); // Relaxed sway
                } else if (expression === 'cocky') {
                    ctx.rotate(Math.sin(timeElapsed * 10) * 0.03); // Confident bob
                } else if (expression === 'dead') {
                    ctx.rotate(Math.PI / 20); // Slight tilt
                }

                // Draw Halo if dead
                if (expression === 'dead') {
                    ctx.save();
                    ctx.strokeStyle = '#ffd700'; // Gold
                    ctx.lineWidth = 4;
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.ellipse(0, -size * 0.7, size * 0.35, size * 0.1, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }

                const headW = size * 1.1;
                const headH = size * 0.9;
                const skin = '#f3d9bf';
                const hair = '#362417';
                const beard = '#3b2418';

                ctx.fillStyle = skin;
                roundRect(ctx, -headW / 2, -headH / 2, headW, headH, headW * 0.2);
                ctx.fill();

                ctx.fillStyle = hair;
                ctx.beginPath();
                ctx.moveTo(-headW / 2 - 6, -headH / 2 + 16);
                ctx.quadraticCurveTo(-headW / 4, -headH / 2 - 14, headW / 4, -headH / 2 + 4);
                ctx.quadraticCurveTo(headW / 2 + 8, -headH / 4, headW / 2 - 4, -headH / 8);
                ctx.lineTo(headW / 2 - 2, headH / 10);
                ctx.quadraticCurveTo(-headW / 4, 0, -headW / 2 + 4, headH / 10);
                ctx.closePath();
                ctx.fill();

                // Glasses frame
                ctx.strokeStyle = '#1e130c';
                ctx.lineWidth = 2.4;

                // Left lens
                roundRect(ctx, -headW * 0.32, -headH * 0.1, headW * 0.24, headH * 0.18, 6);
                if (expression === 'chill') {
                    ctx.fillStyle = '#111';
                    ctx.fill();
                }
                ctx.stroke();

                // Right lens
                roundRect(ctx, headW * 0.08, -headH * 0.1, headW * 0.24, headH * 0.18, 6);
                if (expression === 'chill') {
                    ctx.fillStyle = '#111';
                    ctx.fill();
                }
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(-headW * 0.08, -headH * 0.02);
                ctx.lineTo(headW * 0.08, -headH * 0.02);
                ctx.stroke();

                // Eyes
                if (expression === 'chill') {
                    // Reflection on sunglasses
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.moveTo(-headW * 0.28, -headH * 0.08);
                    ctx.lineTo(-headW * 0.18, -headH * 0.08);
                    ctx.lineTo(-headW * 0.28, 0);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(headW * 0.12, -headH * 0.08);
                    ctx.lineTo(headW * 0.22, -headH * 0.08);
                    ctx.lineTo(headW * 0.12, 0);
                    ctx.fill();
                } else if (expression === 'hit') {
                    // Wincing/Shut eyes
                    ctx.strokeStyle = '#2a1b12';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    // Left eye (shut > <)
                    ctx.moveTo(-headW * 0.25, -headH * 0.06);
                    ctx.lineTo(-headW * 0.15, -headH * 0.02);
                    ctx.moveTo(-headW * 0.15, -headH * 0.06);
                    ctx.lineTo(-headW * 0.25, -headH * 0.02);

                    // Right eye
                    ctx.moveTo(headW * 0.15, -headH * 0.06);
                    ctx.lineTo(headW * 0.25, -headH * 0.02);
                    ctx.moveTo(headW * 0.25, -headH * 0.06);
                    ctx.lineTo(headW * 0.15, -headH * 0.02);
                    ctx.stroke();
                } else if (expression === 'dead') {
                    // X Eyes
                    ctx.strokeStyle = '#2a1b12';
                    ctx.lineWidth = 2.5;
                    const drawXEye = (cx, cy) => {
                        const r = headW * 0.08;
                        ctx.beginPath();
                        ctx.moveTo(cx - r, cy - r);
                        ctx.lineTo(cx + r, cy + r);
                        ctx.moveTo(cx + r, cy - r);
                        ctx.lineTo(cx - r, cy + r);
                        ctx.stroke();
                    };
                    drawXEye(-headW * 0.2, -headH * 0.04);
                    drawXEye(headW * 0.2, -headH * 0.04);
                } else if (expression === 'slap') {
                    // Focused eyes (slightly squinted or angry brows)
                    ctx.fillStyle = '#2a1b12';
                    ctx.beginPath();
                    ctx.ellipse(-headW * 0.2, -headH * 0.03, headW * 0.055, headH * 0.04, 0, 0, Math.PI * 2);
                    ctx.ellipse(headW * 0.2, -headH * 0.03, headW * 0.055, headH * 0.04, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyebrows
                    ctx.strokeStyle = '#2f1d12';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-headW * 0.28, -headH * 0.12);
                    ctx.lineTo(-headW * 0.12, -headH * 0.08);
                    ctx.moveTo(headW * 0.28, -headH * 0.12);
                    ctx.lineTo(headW * 0.12, -headH * 0.08);
                    ctx.stroke();
                } else if (expression === 'cocky') {
                    // Confident eyes with eyebrow raise
                    ctx.fillStyle = '#2a1b12';
                    // Eyes
                    ctx.beginPath();
                    ctx.arc(-headW * 0.2, -headH * 0.03, headW * 0.055, 0, Math.PI * 2);
                    ctx.arc(headW * 0.2, -headH * 0.03, headW * 0.055, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyebrows (One high, one low)
                    ctx.strokeStyle = '#2f1d12';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    // Left (Raised)
                    ctx.moveTo(-headW * 0.28, -headH * 0.15);
                    ctx.quadraticCurveTo(-headW * 0.2, -headH * 0.20, -headW * 0.12, -headH * 0.15);
                    // Right (Lower/Furrowed)
                    ctx.moveTo(headW * 0.12, -headH * 0.08);
                    ctx.quadraticCurveTo(headW * 0.2, -headH * 0.06, headW * 0.28, -headH * 0.08);
                    ctx.stroke();
                } else {
                    // Normal eyes
                    ctx.fillStyle = '#2a1b12';
                    ctx.beginPath();
                    ctx.arc(-headW * 0.2, -headH * 0.03, headW * 0.055, 0, Math.PI * 2);
                    ctx.arc(headW * 0.2, -headH * 0.03, headW * 0.055, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(-headW * 0.19, -headH * 0.05, headW * 0.025, 0, Math.PI * 2);
                    ctx.arc(headW * 0.21, -headH * 0.05, headW * 0.025, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Beard fade
                ctx.fillStyle = beard;
                roundRect(ctx, -headW / 2 + 4, headH / 9, headW - 8, headH / 2.1, headW * 0.2);
                ctx.fillStyle = '#2a1a10';
                ctx.beginPath();
                ctx.moveTo(-headW * 0.18, headH * 0.12);
                ctx.quadraticCurveTo(-headW * 0.06, headH * 0.26, 0, headH * 0.24);
                ctx.quadraticCurveTo(headW * 0.06, headH * 0.26, headW * 0.18, headH * 0.12);
                ctx.fill();
                // Mustache
                ctx.fillStyle = '#2f1d12';
                ctx.beginPath();
                ctx.moveTo(-headW * 0.16, headH * 0.1);
                ctx.quadraticCurveTo(-headW * 0.05, headH * 0.16, 0, headH * 0.12);
                ctx.quadraticCurveTo(headW * 0.05, headH * 0.16, headW * 0.16, headH * 0.1);
                ctx.fill();

                // Mouth/Expression
                if (expression === 'hit') {
                    // Grimace / Wavy mouth
                    ctx.strokeStyle = '#2f1d12'; // Dark brown
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-headW * 0.12, headH * 0.24);
                    ctx.lineTo(-headW * 0.04, headH * 0.20);
                    ctx.lineTo(headW * 0.04, headH * 0.24);
                    ctx.lineTo(headW * 0.12, headH * 0.20);
                    ctx.stroke();
                } else if (expression === 'dead') {
                    // Dead tongue out
                    ctx.fillStyle = '#e57373';
                    ctx.strokeStyle = '#2f1d12';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(-headW * 0.08, headH * 0.22);
                    ctx.quadraticCurveTo(headW * 0.05, headH * 0.35, headW * 0.15, headH * 0.25);
                    ctx.quadraticCurveTo(headW * 0.1, headH * 0.22, -headW * 0.08, headH * 0.22);
                    ctx.fill();
                    ctx.stroke();
                } else if (expression === 'slap') {
                    // Open mouth yelling
                    ctx.fillStyle = '#4a2c22'; // Darker inside mouth
                    ctx.beginPath();
                    ctx.ellipse(0, headH * 0.24, headW * 0.12, headH * 0.08, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (expression === 'chill') {
                    // Cool smirk
                    ctx.strokeStyle = '#1e130c';
                    ctx.lineWidth = 1.6;
                    ctx.beginPath();
                    ctx.moveTo(-headW * 0.1, headH * 0.24);
                    ctx.quadraticCurveTo(0, headH * 0.26, headW * 0.12, headH * 0.22);
                    ctx.stroke();
                } else if (expression === 'cocky') {
                    // Confident smirk
                    ctx.strokeStyle = '#1e130c';
                    ctx.lineWidth = 1.6;
                    ctx.beginPath();
                    // Asymmetrical smile
                    ctx.moveTo(-headW * 0.1, headH * 0.24);
                    ctx.quadraticCurveTo(0, headH * 0.28, headW * 0.12, headH * 0.20);
                    ctx.stroke();
                } else {
                    // Smile
                    ctx.strokeStyle = '#1e130c'; // Ensure color is set
                    ctx.lineWidth = 1.6; // Ensure width is set
                    ctx.beginPath();
                    ctx.moveTo(-headW * 0.1, headH * 0.22);
                    ctx.quadraticCurveTo(0, headH * 0.3, headW * 0.1, headH * 0.22);
                    ctx.stroke();
                }

                // Rose in mouth (Tango style)
                if (hasRose) {
                    const roseX = headW * 0.15;
                    const roseY = headH * 0.22;
                    // Stem
                    ctx.strokeStyle = '#2d6a4f';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(roseX, roseY);
                    ctx.quadraticCurveTo(roseX + 15, roseY + 2, roseX + 25, roseY - 5);
                    ctx.stroke();
                    // Leaf
                    ctx.fillStyle = '#2d6a4f';
                    ctx.beginPath();
                    ctx.ellipse(roseX + 12, roseY + 2, 4, 2, Math.PI / 4, 0, Math.PI * 2);
                    ctx.fill();
                    // Flower
                    ctx.fillStyle = '#d00000';
                    ctx.beginPath();
                    ctx.arc(roseX + 25, roseY - 5, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#9d0208';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(roseX + 25, roseY - 5, 2, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Jaw highlight
                ctx.strokeStyle = 'rgba(255,255,255,0.35)';
                ctx.lineWidth = 1.6;
                ctx.beginPath();
                ctx.moveTo(-headW * 0.18, headH / 2);
                ctx.quadraticCurveTo(0, headH * 0.46, headW * 0.18, headH / 2);
                ctx.stroke();

                // Sparkle for cocky
                if (expression === 'cocky') {
                    ctx.font = '20px "Noto Color Emoji", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('‚ú®', headW * 0.6, -headH * 0.4);
                }

                ctx.restore();
            }

            function drawChancla(ctx, x, y, w, h, isSuper, rotation, isBoomerang) {
                ctx.save();
                ctx.translate(x, y);

                if (isBoomerang) {
                    ctx.save();
                    const iconSize = Math.max(30, w * 1.4);
                    ctx.font = `${iconSize}px 'Noto Color Emoji', sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.globalAlpha = 0.8;
                    // Draw the return icon
                    ctx.fillText('‚Ü©Ô∏è', 0, 0);
                    ctx.restore();
                }

                // Use the thong sandal emoji for the classic "Chancla" look
                const emoji = isSuper ? 'ü©¥üí•' : 'ü©¥üí®';

                // Prioritize Noto Color Emoji and system emoji fonts
                ctx.font = `${Math.max(28, w * 1.4)}px 'Noto Color Emoji', 'Apple Color Emoji', 'Segoe UI Emoji', sans-serif`;
                ctx.textAlign = 'center';
                ctx.rotate(rotation);
                ctx.fillText(emoji, 0, h * 0.2);
                ctx.restore();
            }

            function drawPets() {
                pets.forEach(p => {
                    if (p.kind === 'owen') drawOwen(p);
                    if (p.kind === 'rita') drawRita(p);
                });
            }

            function drawOwen(p) {
                ctx.save();
                ctx.fillStyle = '#444';
                roundRect(ctx, p.x - 25, p.y - 15, 50, 30, 10);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(p.x - 20, p.y - 15);
                ctx.lineTo(p.x - 10, p.y - 35);
                ctx.lineTo(p.x, p.y - 15);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(p.x + 20, p.y - 15);
                ctx.lineTo(p.x + 10, p.y - 35);
                ctx.lineTo(p.x, p.y - 15);
                ctx.fill();
                ctx.fillStyle = '#eee';
                ctx.beginPath();
                ctx.arc(p.x - 8, p.y - 2, 4, 0, Math.PI * 2);
                ctx.arc(p.x + 8, p.y - 2, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#eee';
                ctx.beginPath();
                ctx.arc(p.x, p.y + 6, 10, 0.2 * Math.PI, 0.8 * Math.PI);
                ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Owen Alejandro', p.x, p.y - 24);
                ctx.restore();
            }

            function drawRita(p) {
                ctx.save();
                ctx.fillStyle = '#f2c6de';
                roundRect(ctx, p.x - 23, p.y - 13, 46, 26, 9);
                ctx.fill();
                ctx.fillStyle = '#f7e463';
                ctx.beginPath();
                ctx.moveTo(p.x - 8, p.y - 18);
                ctx.lineTo(p.x - 2, p.y - 30);
                ctx.lineTo(p.x + 4, p.y - 18);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.arc(p.x - 6, p.y - 2, 3.5, 0, Math.PI * 2);
                ctx.arc(p.x + 6, p.y - 2, 3.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#222';
                ctx.beginPath();
                ctx.arc(p.x, p.y + 5, 9, 0.2 * Math.PI, 0.8 * Math.PI);
                ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Rita Cat-Alina', p.x, p.y - 22);
                ctx.restore();
            }

            function drawDialogue() {
                if (dialogueTimer <= 0 || !dialogueText) return;
                const bubbleWidth = 280;
                const x = isa.x - bubbleWidth / 2;
                const y = isa.y + 30;
                ctx.save();
                ctx.fillStyle = 'rgba(31,64,104,0.9)';
                roundRect(ctx, x, y, bubbleWidth, 70, 12);
                ctx.fill();
                ctx.strokeStyle = '#6dd3ff';
                ctx.lineWidth = 2;
                roundRect(ctx, x, y, bubbleWidth, 70, 12);
                ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                wrapText(ctx, dialogueText, isa.x, y + 35, bubbleWidth - 14, 16);
                ctx.restore();
            }

            function drawPlayerDialogue() {
                if (playerDialogueTimer <= 0 || !playerDialogueText) return;
                const bubbleWidth = 220;
                const x = player.x - bubbleWidth / 2;
                const y = player.y - player.h - 80;
                ctx.save();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                roundRect(ctx, x, y, bubbleWidth, 60, 12);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                roundRect(ctx, x, y, bubbleWidth, 60, 12);
                ctx.stroke();

                // Triangle tail
                ctx.beginPath();
                ctx.moveTo(player.x - 10, y + 60);
                ctx.lineTo(player.x, y + 70);
                ctx.lineTo(player.x + 10, y + 60);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#111';
                ctx.font = '13px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                wrapText(ctx, playerDialogueText, player.x, y + 30, bubbleWidth - 14, 16);
                ctx.restore();
            }

            function wrapText(context, text, x, y, maxWidth, lineHeight) {
                const words = text.split(' ');
                let line = '';
                let lines = [];
                for (let n = 0; n < words.length; n++) {
                    const test = line + words[n] + ' ';
                    const metrics = context.measureText(test);
                    if (metrics.width > maxWidth && n > 0) {
                        lines.push(line);
                        line = words[n] + ' ';
                    } else {
                        line = test;
                    }
                }
                lines.push(line);
                lines.forEach((l, i) => context.fillText(l.trim(), x, y + i * lineHeight - (lines.length - 1) * lineHeight / 2));
            }

            function drawLowHealthVignette() {
                if (player.lives > 1) return;

                ctx.save();
                const pulse = (Math.sin(timeElapsed * 8) + 1) / 2;
                const alpha = 0.05 + pulse * 0.25; // Oscillates between 0.05 and 0.3

                const gradient = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, canvas.width * 0.3,
                    canvas.width / 2, canvas.height / 2, canvas.height * 0.8
                );
                gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
                gradient.addColorStop(1, `rgba(220, 20, 60, ${alpha})`);

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

            function drawHUD() {
                ctx.save();
                ctx.fillStyle = '#fff';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('Score: ' + score, 12, 22);
                ctx.textAlign = 'right';
                ctx.fillText('Lives: ' + '‚ù§Ô∏è'.repeat(player.lives), canvas.width - 12, 22);
                if (slowEffect.timer > 0) {
                    ctx.fillStyle = '#ffd166';
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('üç∫ chill ' + slowEffect.timer.toFixed(1) + 's', canvas.width / 2, 22);
                }

                // Draw special attack bar
                const barWidth = 180;
                const barHeight = 20;
                const barX = canvas.width / 2 - barWidth / 2 - 20;
                const barY = 40;

                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                roundRect(ctx, barX, barY, barWidth, barHeight, 10);
                ctx.fill();

                // Fill bar with gradient from blue to red
                if (specialAttackBar > 0) {
                    const progress = specialAttackBar / maxSpecialAttack;
                    const fillWidth = barWidth * progress;

                    const gradient = ctx.createLinearGradient(barX, 0, barX + barWidth, 0);
                    gradient.addColorStop(0, '#4a90e2');
                    gradient.addColorStop(0.5, progress > 0.5 ? '#9b4ae2' : '#4a90e2');
                    gradient.addColorStop(1, progress > 0.7 ? '#e24a4a' : (progress > 0.5 ? '#9b4ae2' : '#4a90e2'));

                    ctx.fillStyle = gradient;
                    ctx.save();
                    ctx.beginPath();
                    roundRect(ctx, barX, barY, fillWidth, barHeight, 10);
                    ctx.clip();
                    roundRect(ctx, barX, barY, fillWidth, barHeight, 10);
                    ctx.fill();
                    ctx.restore();
                }

                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                roundRect(ctx, barX, barY, barWidth, barHeight, 10);
                ctx.stroke();

                // Eggplant emoji
                const p = Math.min(1, specialAttackBar / maxSpecialAttack);
                ctx.save();
                const eggX = barX + barWidth + 20;
                const eggY = barY + barHeight / 2;
                ctx.translate(eggX, eggY);

                let eggScale = 1 + p * 0.4; // up to 1.4x bigger
                let glowIntensity = p * 15;

                // Pulsing effect when ready
                if (p >= 1) {
                    const pulse = Math.sin(timeElapsed * 12); // Pulse speed
                    eggScale += pulse * 0.15;
                    glowIntensity += pulse * 8 + 8; // Pulsing glow
                }

                // Rotate based on progress
                const eggRotation = p * (20 * Math.PI / 180);
                ctx.rotate(eggRotation);
                ctx.scale(eggScale, eggScale);

                // Glow if bar has some progress
                if (p > 0) {
                    ctx.shadowBlur = Math.max(0, glowIntensity);
                    ctx.shadowColor = `rgba(147, 51, 234, ${p})`; // Purple glow
                }

                ctx.font = '28px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üçÜ', 0, 0);
                ctx.restore();

                // "READY!" text
                if (p >= 1) {
                    ctx.save();
                    ctx.translate(eggX, eggY + 28);
                    const textPulse = Math.sin(timeElapsed * 12);
                    const scale = 1 + textPulse * 0.1;
                    ctx.scale(scale, scale);

                    ctx.fillStyle = '#ff79c6';
                    ctx.font = 'bold 12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = '#000';
                    ctx.shadowBlur = 4;
                    ctx.fillText('READY!', 0, 0);
                    ctx.restore();
                }

                // Draw Isa's anger bar
                const angerBarWidth = 150;
                const angerBarHeight = 15;
                const angerBarX = canvas.width / 2 - angerBarWidth / 2;
                const angerBarY = 8;

                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                roundRect(ctx, angerBarX, angerBarY, angerBarWidth, angerBarHeight, 8);
                ctx.fill();

                // Fill bar
                if (isa.anger > 0) {
                    const angerProgress = isa.anger / isa.maxAnger;
                    const angerFillWidth = angerBarWidth * angerProgress;

                    ctx.fillStyle = angerProgress > 0.5 ? '#e24a4a' : '#e2a04a';
                    ctx.save();
                    ctx.beginPath();
                    roundRect(ctx, angerBarX, angerBarY, angerFillWidth, angerBarHeight, 8);
                    ctx.clip();
                    roundRect(ctx, angerBarX, angerBarY, angerFillWidth, angerBarHeight, 8);
                    ctx.fill();
                    ctx.restore();
                }

                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                roundRect(ctx, angerBarX, angerBarY, angerBarWidth, angerBarHeight, 8);
                ctx.stroke();

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText("Isa's Anger", angerBarX + angerBarWidth / 2, angerBarY - 2);

                ctx.restore();
            }

            function drawTitleScreen() {
                drawBackground();
                drawIsa();
                drawPlayer();
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                roundRect(ctx, 30, 260, canvas.width - 60, 200, 16);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.font = '24px sans-serif';
                ctx.fillText('Chancla Bomb', canvas.width / 2, 300);
                ctx.font = '16px sans-serif';
                ctx.fillText('Isa vs. Su Gringo Para Siempre', canvas.width / 2, 330);
                ctx.font = '14px sans-serif';
                ctx.fillText('¬°Manotea (Espacio) las chanclas para regresarlas!', canvas.width / 2, 360);
                ctx.fillStyle = '#ff9f1c';
                roundRect(ctx, 110, 380, canvas.width - 220, 46, 12);
                ctx.fill();
                ctx.fillStyle = '#222';
                ctx.font = '18px sans-serif';
                ctx.fillText('Jugar / Play', canvas.width / 2, 410);
                ctx.restore();
            }

            function drawGameOver() {
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.75)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw Dead Player
                drawPlayerAvatar(ctx, canvas.width / 2, canvas.height / 2 - 80, 80, false, 'dead');

                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.font = '32px sans-serif';
                ctx.fillText('Isa gan√≥', canvas.width / 2, canvas.height / 2 + 10);

                ctx.font = '20px sans-serif';
                ctx.fillText('Score: ' + score + ' | Best: ' + bestScore, canvas.width / 2, canvas.height / 2 + 45);

                ctx.fillStyle = '#dcdcdc';
                ctx.font = 'italic 16px sans-serif';
                ctx.fillText(dialogueText || 'Fue un honor, supongo.', canvas.width / 2, canvas.height / 2 + 75);

                ctx.fillStyle = '#ff9f1c';
                roundRect(ctx, 110, canvas.height / 2 + 110, canvas.width - 220, 50, 12);
                ctx.fill();
                ctx.fillStyle = '#222';
                ctx.font = 'bold 20px sans-serif';
                ctx.fillText('Play Again', canvas.width / 2, canvas.height / 2 + 142);
                ctx.restore();
            }

            function spawnChancla() {
                const isSuper = superEnabled && Math.random() < 0.18;
                const w = isSuper ? 46 : 32;
                const h = isSuper ? 26 : 18;
                const x = 40 + Math.random() * (canvas.width - 80);
                const y = isa.y + 40;
                const vy = baseSpeed + Math.random() * 60 + (isSuper ? 40 : 0);
                const vx = (Math.random() - 0.5) * 60;
                const rotSpeed = (Math.random() - 0.5) * 5;
                chanclas.push({ x, y, vx, vy, w, h, type: isSuper ? 'super' : 'normal', rotation: 0, rotSpeed });
                if (isSuper) sayPlayer('super');
            }

            function spawnOwen() {
                const side = Math.random() < 0.5 ? 'left' : 'right';
                const x = side === 'left' ? -40 : canvas.width + 40;
                const y = canvas.height - 110;
                const vx = side === 'left' ? 180 : -180;
                pets.push({ kind: 'owen', x, y, vx, active: true, duration: 6 });
                sayRandom('petOwen');
            }

            function spawnRita() {
                const x = player.x + (Math.random() * 60 - 30);
                const y = player.y - 80;
                pets.push({ kind: 'rita', x, y, vx: 0, active: true, duration: 3, alpha: 1, dropped: false });
                if (player.lives < player.maxLives) player.lives++;
                baseSpeed *= 0.85;
                sayRandom('petRita');
            }

            function spawnPowerup(kind, x, y) {
                powerups.push({ kind, x, y, vy: 110, w: 38, h: 38 });
            }

            function addFloatText(text, x, y) {
                floatTexts.push({ text, x, y, time: 1.8, max: 1.8 });
            }

            function applyPowerup(p) {
                if (p.kind === 'heart') {
                    if (player.lives < player.maxLives) {
                        player.lives++;
                        addFloatText('I love you! +1 ‚ù§Ô∏è', p.x, p.y);
                    } else {
                        addFloatText('Full coraz√≥n', p.x, p.y);
                    }
                }
                if (p.kind === 'beer') {
                    slowEffect.timer = 4.5;
                    addFloatText('Cerveza chill üç∫', p.x, p.y);
                }
                if (p.kind === 'phone') {
                    isa.chismeTimer = 3.5;
                    addFloatText('¬°Chisme Time! üì±', p.x, p.y);
                    sayRandom('chisme');
                }
            }

            function trySlap() {
                if (slapCooldown > 0) return;

                slapEffect.timer = slapEffect.duration;
                slapEffect.type = 'miss';
                slapEffect.swipeDir = Math.random() < 0.5 ? 1 : -1;

                const slapRange = 80;
                const perfectRange = 50;
                let slappedAny = false;

                for (let i = chanclas.length - 1; i >= 0; i--) {
                    const c = chanclas[i];
                    const dist = Math.sqrt(Math.pow(c.x - player.x, 2) + Math.pow(c.y - player.y, 2));

                    if (dist < slapRange) {
                        // Slap the chancla away
                        const isPerfect = dist < perfectRange;

                        // Upgrade visual effect
                        if (isPerfect) slapEffect.type = 'perfect';
                        else if (slapEffect.type !== 'perfect') slapEffect.type = 'hit';

                        c.vx = (c.x - player.x) * (isPerfect ? 12 : 8);
                        c.vy = isPerfect ? -550 : -300;
                        c.slapped = true;
                        c.isPerfect = isPerfect;
                        c.rotSpeed = (Math.random() < 0.5 ? -1 : 1) * (isPerfect ? 35 : 15 + Math.random() * 10);
                        slappedAny = true;
                        comboCount++;
                        score += comboCount;

                        // Increase special attack bar
                        specialAttackBar = Math.min(maxSpecialAttack, specialAttackBar + (isPerfect ? 25 : 15));

                        if (!specialReadyTriggered && specialAttackBar >= maxSpecialAttack) {
                            specialReadyTriggered = true;
                            // HUD egg icon approx location
                            const eggX = 290;
                            const eggY = 50;
                            spawnImpact(eggX, eggY, true);
                            for (let k = 0; k < 8; k++) {
                                rosePetals.push({
                                    x: eggX, y: eggY,
                                    vx: (Math.random() - 0.5) * 200, vy: (Math.random() - 0.5) * 200,
                                    rotation: Math.random() * 6, rotSpeed: Math.random() * 10,
                                    emoji: '‚ú®', size: 20
                                });
                            }
                            playSound(1200, 0.25);
                            triggerShake(5, 0.2);
                        }

                        const comboPhrase = getComboPhrase(comboCount);
                        const comboText = comboPhrase ? ` x${comboCount} ${comboPhrase}` : ` x${comboCount}`;

                        // Add float text
                        if (isPerfect) {
                            addFloatText('PERFECT!' + comboText, c.x, c.y - 10);
                            spawnImpact(c.x, c.y, true);
                            playSound(850, 0.15);
                            triggerShake(6, 0.2);
                            triggerFlash(0.15, '#fff');
                            hitStop = 0.15;
                            spawnRoseExplosion(c.x, c.y);
                        } else {
                            addFloatText('SLAP!' + comboText, c.x, c.y);
                            spawnImpact(c.x, c.y);
                            playSound(600, 0.1);
                        }

                        if (Math.random() < 0.3) sayRandom('slapSuccess');
                    }
                }

                if (slappedAny) {
                    slapCooldown = 0.3;
                } else {
                    slapCooldown = 0.15;
                    comboCount = 0;
                    playWhoosh();
                    rosePetals.push({
                        x: player.x + (Math.random() - 0.5) * 20,
                        y: player.y - 40,
                        vx: (Math.random() - 0.5) * 50,
                        vy: -50,
                        rotation: Math.random() * Math.PI * 2,
                        rotSpeed: (Math.random() - 0.5) * 5,
                        emoji: 'üí®',
                        size: 24
                    });
                }
            }

            function fireSpecialAttack() {
                if (specialAttackBar >= maxSpecialAttack) {
                    // Fire bouquet emoji at Isa
                    specialProjectiles.push({
                        x: player.x,
                        y: player.y - 20,
                        targetX: isa.x,
                        targetY: isa.y,
                        speed: 400,
                        rotation: 0,
                        rotSpeed: 5,
                        trailTimer: 0
                    });

                    specialAttackBar = 0;
                    specialReadyTriggered = false;

                    // Play special attack sound
                    playSound(800, 0.2);

                    addFloatText('SPECIAL! ü¶µ', player.x, player.y - 30);
                    sayPlayer('fireSpecial');
                }
            }

            function playWhoosh() {
                try {
                    const audioCtx = getAudioContext();
                    if (!audioCtx) return;

                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();

                    osc.connect(gain);
                    gain.connect(audioCtx.destination);

                    // Frequency sweep for whoosh
                    const now = audioCtx.currentTime;
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);

                    // Volume envelope
                    gain.gain.setValueAtTime(0.08, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

                    osc.start(now);
                    osc.stop(now + 0.15);
                } catch (e) {}
            }

            function playSound(frequency, duration) {
                // Simple beep sound using Web Audio API
                try {
                    const audioCtx = getAudioContext();
                    if (!audioCtx) return;

                    const oscillator = audioCtx.createOscillator();
                    const gainNode = audioCtx.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioCtx.destination);

                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';

                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + duration);
                } catch (e) {
                    // Silent fail if audio not supported
                }
            }

            function updateChanclas(dt) {
                const slowFactor = slowEffect.timer > 0 ? slowEffect.factor : 1;
                for (let i = chanclas.length - 1; i >= 0; i--) {
                    const c = chanclas[i];
                    c.x += c.vx * dt;
                    c.y += c.vy * dt * (c.slapped ? 1 : slowFactor);
                    c.rotation += c.rotSpeed * dt;

                    // Remove slapped chanclas that fly off screen
                    if (c.slapped) {
                        // Check for chain reaction with other chanclas
                        for (let j = 0; j < chanclas.length; j++) {
                            if (i === j) continue;
                            const other = chanclas[j];
                            if (!other.slapped) {
                                const distToOther = Math.sqrt(Math.pow(c.x - other.x, 2) + Math.pow(c.y - other.y, 2));
                                if (distToOther < (c.w + other.w) / 2) {
                                    // Chain reaction!
                                    other.slapped = true;
                                    // Push away from the hitting chancla, plus some transferred momentum
                                    let pushX = (other.x - c.x);
                                    // Ensure some horizontal movement if perfectly aligned
                                    if (Math.abs(pushX) < 1) pushX = (Math.random() - 0.5) * 10;

                                    other.vx = pushX * 8 + c.vx * 0.3;
                                    other.vy = -300 + (Math.random() - 0.5) * 100;

                                    comboCount++;
                                    const comboPhrase = getComboPhrase(comboCount);
                                    addFloatText(`CHAIN! x${comboCount} ${comboPhrase}`, other.x, other.y);
                                    spawnImpact(other.x, other.y);
                                    spawnChainEffect(c.x, c.y, other.x, other.y);
                                    playSound(700, 0.1);
                                    score += 5 + comboCount; // Bonus score for chaotic skill
                                }
                            }
                        }

                        // Check collision with Isa for slapped chanclas
                        // Isa radius approx 40. c radius approx w/2.
                        const distToIsa = Math.sqrt(Math.pow(c.x - isa.x, 2) + Math.pow(c.y - isa.y, 2));
                        if (distToIsa < 40 + c.w / 2) {
                            // Hit Isa
                            let damage = c.type === 'super' ? 15 : 8;
                            if (c.isPerfect) damage += 7;

                            isa.anger = Math.max(0, isa.anger - damage);
                            isa.hitTimer = 0.5;

                            if (c.isPerfect) {
                                addFloatText('CRITICAL! üí•', isa.x, isa.y + 30);
                                hitStop = 0.1;
                            }
                            addFloatText('REFLECTED! ‚Ü©Ô∏è', isa.x, isa.y + 10);

                            playSound(900, 0.1); // Higher pitch for success
                            chanclas.splice(i, 1);

                            // Check win
                            if (isa.anger <= 0) {
                                state = STATE.WIN;
                                sayRandom('win');
                            }
                            continue;
                        }

                        if (c.x < -50 || c.x > canvas.width + 50 || c.y < -50) {
                            chanclas.splice(i, 1);
                            continue;
                        }
                    }

                    if (c.x < 10) { c.x = 10; c.vx *= -0.5; }
                    if (c.x > canvas.width - 10) { c.x = canvas.width - 10; c.vx *= -0.5; }

                    if (!c.slapped && rectsOverlap(player, c)) {
                        if (player.shield) {
                            player.shield = false;
                            chanclas.splice(i, 1);
                            continue;
                        }
                        const dmg = c.type === 'super' ? 2 : 1;
                        const wasHighCombo = comboCount >= 5;
                        comboCount = 0;
                        triggerShake(c.type === 'super' ? 15 : 8, 0.4);
                        player.lives -= dmg;
                        player.hitTimer = 0.5;
                        chanclas.splice(i, 1);

                        if (wasHighCombo) {
                            sayRandom('comboBreaker');
                        } else {
                            sayRandom(c.type === 'super' ? 'hitSuper' : 'hitNormal');
                        }

                        sayPlayer('hit');
                        if (player.lives === 1) sayRandom('lowHealth');
                        if (player.lives <= 0) {
                            endGame();
                            return;
                        }
                    } else if (c.y > canvas.height + c.h) {
                        // Boomerang chance!
                        if (!c.isBoomerang && Math.random() < 0.15) {
                            c.isBoomerang = true;
                            c.vy = -Math.abs(c.vy) * 1.1; // Return faster
                            c.vx = (player.x - c.x) * 1.5; // Target player
                            c.rotSpeed *= 3; // Aggressive spin
                            addFloatText('¬°VUELVE!', c.x, c.y - 40);
                            // Do not remove, do not score yet
                        } else {
                            score += 1;
                            const prevBest = bestScore;
                            bestScore = Math.max(bestScore, score);
                            if (score > prevBest && score % 10 === 0) sayRandom('highScore');
                            if (Math.random() < 0.2) sayRandom('nearMiss');
                            if (Math.random() < 0.25) sayPlayer('nearMiss');
                            chanclas.splice(i, 1);
                        }
                    } else if (!c.slapped && c.y < -100) {
                        // Cleanup boomerangs that miss
                        chanclas.splice(i, 1);
                    }
                }
            }

            function updatePets(dt) {
                for (let i = pets.length - 1; i >= 0; i--) {
                    const p = pets[i];
                    p.duration -= dt;
                    if (p.kind === 'owen') {
                        p.x += p.vx * dt;
                        if (!p.dropped && Math.random() < 0.12 * dt) {
                            const type = Math.random() < 0.3 ? 'phone' : 'beer';
                            spawnPowerup(type, p.x, p.y - 10);
                            p.dropped = true;
                        }
                        if (p.x < -60 || p.x > canvas.width + 60 || p.duration <= 0) {
                            pets.splice(i, 1);
                            continue;
                        }
                        for (let j = chanclas.length - 1; j >= 0; j--) {
                            if (rectsOverlap({ x: p.x, y: p.y, w: 50, h: 30 }, chanclas[j])) {
                                chanclas.splice(j, 1);
                            }
                        }
                    } else if (p.kind === 'rita') {
                        p.y += Math.sin(timeElapsed * 3) * 10 * dt;
                        p.alpha = Math.max(0, p.duration / 3);
                        if (!p.dropped && Math.random() < 0.16 * dt) {
                            spawnPowerup('heart', p.x, p.y + 20);
                            p.dropped = true;
                        }
                        if (p.duration <= 0) {
                            pets.splice(i, 1);
                        }
                    }
                }
            }

            function drawPetsOverlay() {
                pets.forEach(p => {
                    if (p.kind === 'rita') {
                        ctx.save();
                        ctx.globalAlpha = p.alpha;
                        drawRita(p);
                        ctx.restore();
                    }
                });
            }

            function drawPowerups() {
                powerups.forEach(p => {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    const scale = p.w / 26;
                    ctx.scale(scale, scale);
                    if (p.kind === 'heart') {
                        ctx.fillStyle = '#ff6fae';
                        ctx.beginPath();
                        ctx.moveTo(0, 6);
                        ctx.bezierCurveTo(-12, -8, -2, -16, 0, -8);
                        ctx.bezierCurveTo(2, -16, 12, -8, 0, 6);
                        ctx.fill();
                        ctx.fillStyle = '#fff';
                        ctx.font = '11px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('I ‚ù§Ô∏è U', 0, 22);
                    } else if (p.kind === 'beer') {
                        ctx.fillStyle = '#f2c94c';
                        roundRect(ctx, -12, -18, 24, 36, 6);
                        ctx.fill();
                        ctx.fillStyle = '#fff3a3';
                        roundRect(ctx, -10, -22, 20, 10, 4);
                        ctx.fill();
                        ctx.fillStyle = '#5f4b32';
                        ctx.font = '12px sans-serif';
                        ctx.fillText('üç∫', 0, 6);
                    } else if (p.kind === 'phone') {
                        ctx.fillStyle = '#333';
                        roundRect(ctx, -14, -20, 28, 44, 4);
                        ctx.fill();
                        ctx.fillStyle = '#111';
                        roundRect(ctx, -12, -18, 24, 40, 2);
                        ctx.fill();
                        ctx.fillStyle = '#fff';
                        ctx.font = '20px sans-serif';
                        ctx.fillText('üì±', 0, 8);
                    }
                    ctx.restore();
                });
            }

            function drawFloatTexts() {
                floatTexts.forEach(f => {
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, f.time / f.max);
                    ctx.fillStyle = '#fff';
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(f.text, f.x, f.y);
                    ctx.restore();
                });
            }

            function rectsOverlap(a, b) {
                return Math.abs(a.x - b.x) < (a.w / 2 + b.w / 2) && Math.abs(a.y - b.y) < (a.h / 2 + b.h / 2);
            }

            function updatePowerups(dt) {
                for (let i = powerups.length - 1; i >= 0; i--) {
                    const p = powerups[i];
                    p.y += p.vy * dt;
                    if (rectsOverlap(player, p)) {
                        applyPowerup(p);
                        powerups.splice(i, 1);
                        continue;
                    }
                    if (p.y > canvas.height + p.h) {
                        powerups.splice(i, 1);
                    }
                }
                for (let i = floatTexts.length - 1; i >= 0; i--) {
                    const f = floatTexts[i];
                    f.y -= 18 * dt;
                    f.time -= dt;
                    if (f.time <= 0) floatTexts.splice(i, 1);
                }
            }

            function updateSpecialProjectiles(dt) {
                for (let i = specialProjectiles.length - 1; i >= 0; i--) {
                    const proj = specialProjectiles[i];

                    // Move towards Isa
                    const dx = proj.targetX - proj.x;
                    const dy = proj.targetY - proj.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Rotate projectile
                    proj.rotation += proj.rotSpeed * dt;

                    // Spawn Trail (Hearts/Sparkles)
                    proj.trailTimer = (proj.trailTimer || 0) + dt;
                    if (proj.trailTimer > 0.05) {
                        proj.trailTimer = 0;
                        rosePetals.push({
                            x: proj.x + (Math.random() - 0.5) * 20,
                            y: proj.y + (Math.random() - 0.5) * 20,
                            vy: 50, // slowly fall
                            rotation: Math.random() * Math.PI * 2,
                            rotSpeed: (Math.random() - 0.5) * 2,
                            emoji: Math.random() < 0.7 ? 'üí¶' : '‚ú®',
                            size: 16
                        });
                    }

                    if (dist < 15) {
                        // Hit Isa!
                        isa.anger = Math.max(0, isa.anger - 20);
                        isa.hitTimer = 0.7;
                        specialProjectiles.splice(i, 1);

                        // Play hit sound
                        playSound(1000, 0.15);

                        const hitWords = dialogue.hitBySpecial;
                        const word = hitWords[Math.floor(Math.random() * hitWords.length)];
                        addFloatText(word + ' ‚ù§Ô∏è', isa.x, isa.y);
                        sayRandom('hitBySpecial');

                        // Spawn Impact Explosion
                        for (let k = 0; k < 15; k++) {
                            const angle = (Math.PI * 2 * k) / 15;
                            const speed = 150 + Math.random() * 150;
                            rosePetals.push({
                                x: isa.x,
                                y: isa.y,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                rotation: Math.random() * Math.PI * 2,
                                rotSpeed: (Math.random() - 0.5) * 10,
                                emoji: Math.random() < 0.5 ? '‚ú®' : 'üí®',
                                size: 24
                            });
                        }

                        // Check for win
                        if (isa.anger <= 0) {
                            state = STATE.WIN;
                            sayRandom('win');
                        }
                        continue;
                    }

                    proj.x += (dx / dist) * proj.speed * dt;
                    proj.y += (dy / dist) * proj.speed * dt;
                }
            }

            function drawSpecialProjectiles() {
                specialProjectiles.forEach(proj => {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    ctx.rotate(proj.rotation);
                    ctx.font = '70px "Noto Color Emoji", "Apple Color Emoji", "Segoe UI Emoji", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ü¶µ', 0, 0);
                    ctx.restore();
                });
            }

            function endGame() {
                state = STATE.GAMEOVER;
                bestScore = Math.max(bestScore, score);
                sayRandom('gameOver');
            }

            function update(dt) {
                if (state !== STATE.PLAYING) return;

                if (shakeTimer > 0) {
                    shakeTimer -= dt;
                    const dx = (Math.random() - 0.5) * shakeIntensity * 2;
                    const dy = (Math.random() - 0.5) * shakeIntensity * 2;
                    wrapper.style.transform = `translate(${dx}px, ${dy}px)`;
                    if (shakeTimer <= 0) wrapper.style.transform = 'none';
                }

                if (flash.timer > 0) {
                    flash.timer -= dt;
                }

                if (hitStop > 0) {
                    hitStop -= dt;
                    return;
                }

                timeElapsed += dt;
                spawnTimer += dt;
                if (timeElapsed > 12) {
                    spawnInterval = Math.max(minSpawnInterval, spawnInterval - dt * 0.02);
                    baseSpeed += dt * 5;
                }
                if (timeElapsed > 18) superEnabled = true;
                if (spawnTimer >= spawnInterval && isa.chismeTimer <= 0) {
                    spawnChancla();
                    spawnTimer = 0;
                }

                const speed = player.speed;
                const moveLeft = keys.left || touch.left;
                const moveRight = keys.right || touch.right;
                if (moveLeft) player.x -= speed * dt;
                if (moveRight) player.x += speed * dt;
                player.x = Math.max(player.w / 2 + 10, Math.min(canvas.width - player.w / 2 - 10, player.x));

                if (!pets.some(p => p.kind === 'owen') && (player.lives <= 2 && Math.random() < 0.003 || Math.random() < 0.0007)) {
                    spawnOwen();
                }
                if (!pets.some(p => p.kind === 'rita') && Math.random() < 0.0007) {
                    spawnRita();
                }

                updateChanclas(dt);
                updatePets(dt);
                updatePowerups(dt);
                updateSpecialProjectiles(dt);
                updateImpacts(dt);
                updateChainEffects(dt);

                // Update rose petals
                for (let i = rosePetals.length - 1; i >= 0; i--) {
                    const p = rosePetals[i];

                    if (p.vx !== undefined) {
                        p.x += p.vx * dt;
                        p.y += p.vy * dt;
                        p.vx *= 0.95; // Drag
                        p.vy += 200 * dt; // Gravity
                    } else {
                        p.y += p.vy * dt;
                        p.x += Math.sin(timeElapsed * 2 + p.offset) * 20 * dt;
                    }

                    p.rotation += p.rotSpeed * dt;
                    if (p.y > canvas.height + 20) {
                        rosePetals.splice(i, 1);
                    }
                }

                // Spawn rose petals if special is ready
                if (specialAttackBar >= maxSpecialAttack) {
                    if (Math.random() < 0.15) { // Spawn chance per frame
                        rosePetals.push({
                            x: player.x + (Math.random() - 0.5) * 40,
                            y: player.y - 40,
                            vy: 60 + Math.random() * 40,
                            rotation: Math.random() * Math.PI * 2,
                            rotSpeed: (Math.random() - 0.5) * 4,
                            offset: Math.random() * 10
                        });
                    }
                }

                if (slowEffect.timer > 0) slowEffect.timer -= dt;
                if (slapCooldown > 0) slapCooldown -= dt;
                if (slapEffect.timer > 0) slapEffect.timer -= dt;
                if (isa.hitTimer > 0) isa.hitTimer -= dt;
                if (player.hitTimer > 0) player.hitTimer -= dt;
                if (isa.chismeTimer > 0) isa.chismeTimer -= dt;

                if (dialogueTimer > 0) dialogueTimer -= dt;
                if (playerDialogueTimer > 0) playerDialogueTimer -= dt;
                if (Math.random() < 0.002) sayPlayer('idle');
            }

            function draw() {
                drawBackground();
                drawIsa();
                drawChanclasAll();
                drawPowerups();
                drawSpecialProjectiles();
                drawPets();
                drawRosePetals();
                drawChainEffects();
                drawImpacts();
                drawPlayer();
                drawSlapEffect();
                drawPetsOverlay();
                drawLowHealthVignette();
                drawFlash();
                drawHUD();
                drawFloatTexts();
                drawDialogue();
                drawPlayerDialogue();
            }

            function drawChanclasAll() {
                for (const c of chanclas) drawChancla(ctx, c.x, c.y, c.w, c.h, c.type === 'super', c.rotation, c.isBoomerang);
            }

            function drawWinScreen() {
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw Isa moving down and embracing
                if (winAnimationStart === 0) winAnimationStart = Date.now();
                const winProgress = Math.min(1, (Date.now() - winAnimationStart) / 3000);
                const isaWinY = 70 + (player.y - 100 - 70) * winProgress;
                drawIsaAvatar(ctx, isa.x, isaWinY, 78);

                // Speech bubble
                if (winProgress > 0.7) {
                    const bubbleWidth = 280;
                    const bubbleX = canvas.width / 2 - bubbleWidth / 2;
                    const bubbleY = isaWinY + 50;

                    ctx.fillStyle = 'rgba(255, 192, 203, 0.95)';
                    roundRect(ctx, bubbleX, bubbleY, bubbleWidth, 70, 12);
                    ctx.fill();
                    ctx.strokeStyle = '#ff69b4';
                    ctx.lineWidth = 2;
                    roundRect(ctx, bubbleX, bubbleY, bubbleWidth, 70, 12);
                    ctx.stroke();

                    ctx.fillStyle = '#333';
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    wrapText(ctx, dialogueText || "Te amo, Papi. I only hit you because I love you", canvas.width / 2, bubbleY + 35, bubbleWidth - 14, 16);
                }

                // Ending caption
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.font = '32px sans-serif';
                ctx.fillText("YOU WIN! üéâ", canvas.width / 2, 200);
                ctx.font = '20px sans-serif';
                ctx.fillText("You've survived another day...", canvas.width / 2, 240);

                // Play again button
                ctx.fillStyle = '#ff9f1c';
                roundRect(ctx, 110, 550, canvas.width - 220, 50, 12);
                ctx.fill();
                ctx.fillStyle = '#222';
                ctx.font = '20px sans-serif';
                ctx.fillText('Play again', canvas.width / 2, 582);

                ctx.restore();
            }

            let last = 0;
            function loop(ts) {
                const now = ts / 1000;
                const dt = last ? Math.min(0.05, now - last) : 0;
                last = now;
                if (state === STATE.PLAYING || state === STATE.WIN) update(dt);
                if (state === STATE.TITLE) drawTitleScreen();
                else if (state === STATE.WIN) {
                    draw();
                    drawWinScreen();
                } else {
                    draw();
                    if (state === STATE.GAMEOVER) drawGameOver();
                }
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);

            function startGameFromTitle() {
                resetGame();
            }

            function setDirectionsVisible(show) {
                body.classList.toggle('hide-directions', !show);
            }

            canvas.addEventListener('click', (e) => {
                if (state === STATE.TITLE) {
                    startGameFromTitle();
                } else if (state === STATE.GAMEOVER || state === STATE.WIN) {
                    resetGame();
                }
            });

            canvas.addEventListener('touchstart', (e) => {
                if (state === STATE.TITLE) { startGameFromTitle(); return; }
                if (state === STATE.GAMEOVER || state === STATE.WIN) { resetGame(); return; }

                if (state === STATE.PLAYING) {
                    const rect = canvas.getBoundingClientRect();
                    const touchPoint = e.touches[0];
                    const x = touchPoint.clientX - rect.left;
                    const y = touchPoint.clientY - rect.top;
                    const relativeY = y / rect.height;

                    // If tapping in the upper area (not movement zones at bottom), trigger slap
                    if (relativeY < 0.6) {
                        if (specialAttackBar >= maxSpecialAttack) {
                            fireSpecialAttack();
                        } else {
                            trySlap();
                        }
                    } else {
                        // Movement controls for bottom area
                        if (x < rect.width / 2) touch.left = true; else touch.right = true;
                    }
                }
            }, { passive: true });
            canvas.addEventListener('touchend', () => { touch.left = false; touch.right = false; });

            function handleKey(e, isDown) {
                if (['ArrowLeft', 'a', 'A'].includes(e.key)) { keys.left = isDown; e.preventDefault(); }
                if (['ArrowRight', 'd', 'D'].includes(e.key)) { keys.right = isDown; e.preventDefault(); }

                // Slap key - spacebar
                if (e.key === ' ' || e.key === 'Spacebar') {
                    if (isDown && state === STATE.PLAYING) {
                        if (specialAttackBar >= maxSpecialAttack) {
                            fireSpecialAttack();
                        } else {
                            trySlap();
                        }
                    }
                    e.preventDefault();
                }

                if (isDown && e.key === 'Enter' && state !== STATE.PLAYING) {
                    resetGame();
                }
            }
            window.addEventListener('keydown', e => handleKey(e, true));
            window.addEventListener('keyup', e => handleKey(e, false));

            function updateTouchOverlay() {
                overlayLeft.style.background = touch.left ? 'rgba(255,255,255,0.06)' : 'transparent';
                overlayRight.style.background = touch.right ? 'rgba(255,255,255,0.06)' : 'transparent';
                requestAnimationFrame(updateTouchOverlay);
            }
            updateTouchOverlay();

            function handleMobileZones(zone, dir) {
                zone.addEventListener('touchstart', (e) => {
                    if (state !== STATE.PLAYING) return;
                    touch[dir] = true;
                    e.preventDefault();
                }, { passive: false });
                zone.addEventListener('touchend', () => { touch[dir] = false; });
                zone.addEventListener('touchcancel', () => { touch[dir] = false; });
            }
            handleMobileZones(touchLeft, 'left');
            handleMobileZones(touchRight, 'right');

            document.getElementById('mobile-controls').addEventListener('touchstart', () => {
                if (state === STATE.TITLE) startGameFromTitle();
                else if (state === STATE.GAMEOVER || state === STATE.WIN) resetGame();
            }, { passive: true });

            function resize() {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                canvas.dataset.scaleX = scaleX;
                canvas.dataset.scaleY = scaleY;
                const control = document.getElementById('mobile-controls');
                control.style.width = rect.width + 'px';
                buildBackgroundElements();
            }
            window.addEventListener('resize', resize);
            resize();

            function initTitle() {
                sayRandom('start');
                setDirectionsVisible(true);
            }
            initTitle();
        })();
    </script>
</body>

</html>